from __future__ import annotations

import contextlib
import functools
import itertools
import operator
from abc import ABC, abstractmethod
from typing import (
    Callable,
    Dict,
    Generic,
    Hashable,
    Iterable,
    Iterator,
    List,
    Reversible,
    Set,
    Tuple,
    TypeVar,
    Union,
    overload
)

from .objects import require_not_none, identity
from .optional import Optional

__all__ = [
    'Stream'
]

T = TypeVar('T')
T_co = TypeVar('T_co', covariant=True)
K = TypeVar('K', bound=Hashable)
V = TypeVar('V')

_not_defined = object()


class Stream(ABC, Generic[T_co]):  # pylint: disable=too-many-public-methods
    """
    A sequence of elements supporting sequential and parallel operations.

    To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline
    consists of a source (which might be an array, a collection, a generator function, etc.), zero or more
    intermediate operations (which transform a stream into another stream, such as filter(Predicate)),
    and a terminal operation (which produces a result or side effect, such as count() or for_each(Consumer)).
    Streams are lazy; computation on the source data is only performed when the terminal operation is initiated,
    and source elements are consumed only as needed.
    """

    @staticmethod
    @overload
    def of(iterable: Iterable[T]) -> Stream[T]: ...

    @staticmethod
    @overload
    def of(*values: T) -> Stream[T]: ...

    @staticmethod
    def of(*args) -> Stream[T]:
        """
        Creates a new sequential Stream from an Iterable object or from specified elements.

        :param iterable: an Iterable object describing the stream elements
        :param args: the elements of the new stream
        :return: a new sequential Stream
        """

        return _SequentialStream.of(*args)

    @staticmethod
    def empty() -> Stream[T]:
        """
        Returns an empty sequential Stream.

        :return: a empty sequential Stream
        """

        return Stream.of(())

    @staticmethod
    def generate(supplier: Callable[[], T]) -> Stream[T]:
        """
        Returns an infinite sequential unordered stream where each element is generated by the provided Supplier.

        :param supplier: the Supplier of generated elements
        :return: a new infinite sequential unordered Stream
        """

        return _SequentialStream.generate(supplier)

    @staticmethod
    @overload
    def range(stop: int) -> Stream[int]: ...

    @staticmethod
    @overload
    def range(start: int, stop: int) -> Stream[int]: ...

    @staticmethod
    @overload
    def range(start: int, stop: int, step: int) -> Stream[int]: ...

    @staticmethod
    def range(*args) -> Stream[int]:
        """
        Return a Stream of integers from start (inclusive) to stop (exclusive) by step.

        :param start: position to start (default 0)
        :param stop: position to stop
        :param step: step of incrementation (default 1)
        :return: a new int sequential Stream
        """

        return Stream.of(range(*args))

    @abstractmethod
    def filter(self: Stream[T], predicate: Callable[[T], bool]) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream that match the given predicate.

        :param predicate: stateless function to apply to each element to determine if it should be included
        :return: the new Stream
        """

    @abstractmethod
    def map(self: Stream[T], mapper: Callable[[T], V]) -> Stream[V]:
        """
        Returns a Stream consisting of the results of applying the given function to the elements of this Stream.

        :param mapper: stateless function to apply to each element
        :return: the new Stream
        """

    @abstractmethod
    def flat_map(self: Stream[T], mapper: Callable[[T], Iterable[V]]) -> Stream[V]:
        """
        Returns a Stream consisting of the results of replacing each element of this Stream with the contents
        produced by applying the provided mapping function to each element.

        :param mapper: stateless function to apply to each element which produces of new values
        :return: the new Stream
        """

    @overload
    def distinct(self: Stream[T]) -> Stream[T]: ...

    @overload
    def distinct(self: Stream[T], comparator: Callable[[T], K]) -> Stream[T]: ...

    @abstractmethod
    def distinct(self: Stream[T], comparator: Callable[[T], K] = identity) -> Stream[T]:
        """
        Returns a stream consisting of the distinct elements of this Stream.

        :param comparator: stateless function to apply to each element which serves as a basis for comparison.
        :return: the new Stream
        """

    @overload
    def sorted(self: Stream[T]) -> Stream[T]: ...

    @overload
    def sorted(self: Stream[T], reverse: bool) -> Stream[T]: ...

    @overload
    def sorted(self: Stream[T], comparator: Callable[[T], K]) -> Stream[T]: ...

    @overload
    def sorted(self: Stream[T], comparator: Callable[[T], K], reverse: bool) -> Stream[T]: ...

    @abstractmethod
    def sorted(self: Stream[T], comparator: Callable[[T], K] = identity, reverse: bool = False) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream, sorted according to the provided comparator.
        This is a stateful intermediate operation.

        :param comparator: stateless function to apply to each element which serves as a basis for comparison
        :param reverse: If True, then a stream would be sorted in reverse (descending) order
        :return: the new Stream
        """

    @abstractmethod
    def reversed(self: Stream[T]) -> Stream[T]:
        """
        Return a reverse Stream over the values of the given Stream.

        :return: the new Stream
        """

    @abstractmethod
    def peek(self: Stream[T], consumer: Callable[[T], None]) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream, additionally performing the provided action
        on each element as elements are consumed from the resulting Stream.

        :param consumer: a non-interfering action to perform on the elements as they are consumed from the stream
        :return: the new Stream
        """

    @abstractmethod
    def enumerate(self: Stream[T]) -> Stream[Tuple[int, T]]:
        """
        Returns a pair Stream consisting of the elements of this Stream with their natural index

        :return: the new Stream
        """

    @abstractmethod
    def zip(self: Stream[T], other: Stream[V]) -> Stream[Tuple[T, V]]:
        """
        Returns a Stream consisting of the elements of this Stream merged with other Stream by element index.

        :param other: second input Stream to zip
        :return: the new pair Stream
        """

    @abstractmethod
    def limit(self: Stream[T], max_size: int) -> Stream[T]:
        """
        Returns a Stream consisting of the elements of this Stream, truncated to be no longer than max_size in length.

        :param max_size: the number of elements the stream should be limited to
        :return: the new Stream
        """

    @abstractmethod
    def skip(self: Stream[T], n: int) -> Stream[T]:
        """
        Returns a Stream consisting of the remaining elements of this stream after discarding the first n elements
        of the Stream.

        :param n: the number of leading elements to skip
        :return: the new Stream
        """

    @abstractmethod
    def take_while(self: Stream[T], predicate: Callable[[T], bool]) -> Stream[T]:
        """
        Returns a stream consisting of the longest prefix of elements taken from this stream that match
        the given predicate.

        :param predicate: a non-interfering, stateless predicate to apply to elements to determine the longest
        prefix of elements.
        :return: the new Stream
        """

    @abstractmethod
    def drop_while(self: Stream[T], predicate: Callable[[T], bool]) -> Stream[T]:
        """
        Returns a stream consisting of the remaining elements of this stream after dropping the longest prefix
        of elements that match the given predicate.

        :param predicate: a non-interfering, stateless predicate to apply to elements to determine the longest
        prefix of elements.
        :return: the new Stream
        """

    @abstractmethod
    def union(self: Stream[T], other: Stream[V]) -> Stream[Union[T, V]]:
        """
        Creates a lazily concatenated stream whose elements are all the elements of this stream
        followed by all the elements of the other stream.

        :param other: second input stream to concatenate
        :return: new the concatenation of the two streams
        """

    @abstractmethod
    def transform(self: Stream[T], transform: Callable[[Stream[T]], Stream[V]]) -> Stream[V]:
        """
        Returns a new Stream after applying function. Concise syntax for chaining custom transformations.

        :param transform: a function that takes and returns a Stream
        :return: a new Stream
        """

    @abstractmethod
    def materialize(self: Stream[T]) -> Stream[T]:
        """
        Materialize this Stream and returns a new Stream consisting of the same elements of this Stream
        This is a terminal operation.

        :return: a new Stream
        """

    @abstractmethod
    def for_each(self: Stream[T], consumer: Callable[[T], None]) -> None:
        """
        Performs an action for each element of this stream.
        This is a terminal operation.

        :param consumer: a non-interfering action to perform on the elements
        """

    @abstractmethod
    def collect(self: Stream[T], collector: Callable[[Iterator[T]], V]) -> V:
        """
        Performs a mutable reduction operation on the elements of this Stream, using the provided collector function
        to allocate the returned value.
        This is a terminal operation.

        :param collector: a function that creates a new mutable result container.
        :return: the result of the collector function
        """

    @abstractmethod
    def iterator(self: Stream[T]) -> Iterator[T]:
        """
        Returns an iterator that iterate over the elements of this Stream.
        This is a terminal operation.

        :return: an iterator containing the Stream elements
        """

    @abstractmethod
    def to_list(self: Stream[T]) -> List[T]:
        """
        Accumulates the elements of this Stream into a list.
        This is a terminal operation.

        :return: a list containing the stream elements
        """

    @abstractmethod
    def to_set(self: Stream[T]) -> Set[T]:
        """
        Accumulates the elements of this Stream into a set.
        This is a terminal operation.

        :return: a set containing the stream elements
        """

    @abstractmethod
    def to_dict(self: Stream[Tuple[K, V]]) -> Dict[K, V]:
        """
        Accumulates the elements of this Stream into a dict whose keys and values come from tuple of elements.
        This is a terminal operation.

        :return: a dict containing the stream elements
        """

    @overload
    def reduce(self: Stream[T], accumulator: Callable[[T, T], T]) -> Optional[T]: ...

    @overload
    def reduce(self: Stream[T], accumulator: Callable[[T, T], T], initial: T) -> T: ...

    @abstractmethod
    def reduce(self: Stream[T], accumulator: Callable[[T, T], T], initial: T = _not_defined) -> Union[T, Optional[T]]:
        """
        Performs a reduction on the elements of this Stream, using an associative accumulation function,
        and returns the reduced value, if any.
        This is a terminal operation.

        :param accumulator: an associative, non-interfering, stateless function for combining two values
        :param initial: if present, it is placed before the items of the sequence in the calculation
        :return: the result of the reduction
        """

    @overload
    def min(self: Stream[T]) -> Optional[T]: ...

    @overload
    def min(self: Stream[T], comparator: Callable[[T], V]) -> Optional[T]: ...

    @abstractmethod
    def min(self: Stream[T], comparator: Callable[[T], V] = identity) -> Optional[T]:
        """
        Returns the minimum element of this stream according to the provided Comparator.
        This is a terminal operation.

        :param comparator: a non-interfering, stateless comparator to compare elements of this stream
        :return: an Optional describing the minimum element of this stream
        """

    @overload
    def max(self: Stream[T]) -> Optional[T]: ...

    @overload
    def max(self: Stream[T], comparator: Callable[[T], V]) -> Optional[T]: ...

    @abstractmethod
    def max(self: Stream[T], comparator: Callable[[T], V] = identity) -> Optional[T]:
        """
        Returns the maximum element of this stream according to the provided Comparator.
        This is a terminal operation.

        :param comparator: a non-interfering, stateless comparator to compare elements of this stream
        :return: an Optional describing the maximum element of this stream
        """

    @abstractmethod
    def count(self: Stream[T]) -> int:
        """
        Returns the count of elements in this Stream.
        This is a terminal operation.

        :return: the count of elements in this Stream
        """

    @overload
    def any_match(self: Stream[T]) -> bool: ...

    @overload
    def any_match(self: Stream[T], predicate: Callable[[T], bool]) -> bool: ...

    @abstractmethod
    def any_match(self: Stream[T], predicate: Callable[[T], bool] = bool) -> bool:
        """
        Returns whether any elements of this stream match the provided predicate.
        This is a terminal operation.

        :param predicate: a non-interfering, stateless predicate to apply to elements of this stream
        :return: True if any elements of the stream match the provided predicate, otherwise False
        """

    @overload
    def all_match(self: Stream[T]) -> bool: ...

    @overload
    def all_match(self: Stream[T], predicate: Callable[[T], bool]) -> bool: ...

    @abstractmethod
    def all_match(self: Stream[T], predicate: Callable[[T], bool] = bool) -> bool:
        """
        Returns whether all elements of this stream match the provided predicate.
        This is a terminal operation.

        :param predicate: a non-interfering, stateless predicate to apply to elements of this stream
        :return: True if either all elements of the stream match the provided predicate or the stream is empty,
        otherwise False
        """

    @overload
    def none_match(self: Stream[T]) -> bool: ...

    @overload
    def none_match(self: Stream[T], predicate: Callable[[T], bool]) -> bool: ...

    @abstractmethod
    def none_match(self: Stream[T], predicate: Callable[[T], bool] = bool) -> bool:
        """
        Returns whether no elements of this stream match the provided predicate.
        This is a terminal operation.

        :param predicate: a non-interfering, stateless predicate to apply to elements of this stream
        :return: True if either no elements of the stream match the provided predicate or the stream is empty,
        otherwise False
        """

    @abstractmethod
    def find_first(self: Stream[T]) -> Optional[T]:
        """
        Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty.
        This is a terminal operation.

        :return: an Optional describing the first element of this stream, or an empty Optional if the stream is empty
        """

    @abstractmethod
    def key_by(self: Stream[T], mapper: Callable[[T], K]) -> Stream[Tuple[K, T]]:
        """
        Returns a pair Stream consisting elements of this Stream by applying mapper function.

        :param mapper: stateless function to apply to each element and result used as key
        :return: the new pair Stream
        """

    @abstractmethod
    def keys(self: Stream[Tuple[K, V]]) -> Stream[K]:
        """
        Returns a new Stream consisting keys of this Stream.

        :return: the new Stream
        """

    def values(self: Stream[Tuple[K, V]]) -> Stream[V]:
        """
        Returns a new Stream consisting values of this Stream.

        :return: the new Stream
        """

    @abstractmethod
    def map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], T]) -> Stream[Tuple[K, T]]:
        """
        Returns a Stream consisting of the results of applying the given function to value of this Stream elements.

        :param mapper: stateless function to apply to each element value
        :return: the new Stream
        """

    @abstractmethod
    def flat_map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], Iterable[T]]) -> Stream[Tuple[K, T]]:
        """
        Returns a Stream consisting of the results of replacing each value of this Stream elements with the contents
        produced by applying the provided mapping function to each element value.

        :param mapper: stateless function to apply to each element value which produces of new values
        :return: the new Stream
        """

    @overload
    def group_by(self: Stream[T], classifier: Callable[[T], K]) -> Stream[Tuple[K, Iterable[T]]]: ...

    @overload
    def group_by(
            self: Stream[T], classifier: Callable[[T], K], downstream: Callable[[T], V]
    ) -> Stream[Tuple[K, Iterable[V]]]: ...

    @abstractmethod
    def group_by(
            self: Stream[T], classifier: Callable[[T], K], downstream: Callable[[T], V] = identity
    ) -> Stream[Tuple[K, Iterable[V]]]:
        """
        Returns a Stream consisting grouping elements of this Stream according to a classification function,
        and then performing a mapping operation on the values associated with a given key using the specified
        downstream function.

        :param classifier: a classifier function mapping input elements to keys
        :param downstream: stateless function to apply to each downstream element
        :return: the new pair Stream
        """

    @overload
    def group_by_key(self: Stream[Tuple[K, V]]) -> Stream[Tuple[K, Iterable[V]]]: ...

    @overload
    def group_by_key(self: Stream[Tuple[K, V]], downstream: Callable[[V], T]) -> Stream[Tuple[K, Iterable[T]]]: ...

    @abstractmethod
    def group_by_key(
            self: Stream[Tuple[K, V]], downstream: Callable[[V], T] = identity
    ) -> Stream[Tuple[K, Iterable[T]]]:
        """
        Returns a Stream consisting grouping elements of this pair Stream according to a key value,
        and then performing a mapping operation on the values associated with a given key using the specified
        downstream function.

        :param downstream: stateless function to apply to each downstream element
        :return: the new pair Stream
        """

    @overload
    def reduce_by_key(self: Stream[Tuple[K, V]], accumulator: Callable[[V, V], V]) -> Stream[Tuple[K, V]]: ...

    @overload
    def reduce_by_key(
            self: Stream[Tuple[K, V]], accumulator: Callable[[T, V], T], initial: T
    ) -> Stream[Tuple[K, T]]: ...

    @abstractmethod
    def reduce_by_key(
            self: Stream[Tuple[K, V]], accumulator: Callable[[T, V], T], initial: T = _not_defined
    ) -> Stream[Tuple[K, T]]:
        """
        Returns a Stream consisting key and reduced values of this Stream, using an associative accumulation function.

        :param accumulator: a stateless function used to reduce the input elements
        :param initial: the identity value for the reduction
        :return: the new pair Stream
        """

    @overload
    def joining(self: Stream[str]) -> str: ...

    @overload
    def joining(self: Stream[str], delimiter: str) -> str: ...

    @overload
    def joining(self: Stream[str], delimiter: str, prefix: str, suffix: str) -> str: ...

    @abstractmethod
    def joining(self: Stream[str], delimiter: str = '', prefix: str = '', suffix: str = '') -> str:
        """
        Concatenates the input Stream, separated by the specified delimiter, with the specified prefix and suffix,
        in encounter order.
        This is a terminal operation.

        :param delimiter: the delimiter to be used between each element
        :param prefix: the sequence of characters to be used at the beginning of the joined result
        :param suffix: the sequence of characters to be used at the end of the joined result
        :return: concatenated sting
        """

    @abstractmethod
    def __iter__(self): ...


class _PipelineStage:
    """
    Helper class for stream pipelines that contain no data manipulation logic
    """

    def __init__(self, parent: _PipelineStage, materialized=False) -> None:
        self.__parent = Optional.of_nullable(parent)
        self.__materialized = materialized
        self.__consuming_state = self.__parent \
            .map(_PipelineStage.__is_consumed) \
            .or_else(False)

    @contextlib.contextmanager
    def _disposable_consume(self):
        if self.__is_consumed():
            raise ValueError('stream has already been operated upon or closed')
        yield
        self.__mark_as_consumed()

    def __is_consumed(self) -> bool:
        return self.__parent \
            .map(lambda parent: parent.__is_consumed() or self.__consuming_state) \
            .or_else(self.__consuming_state)  # pylint: disable=protected-access

    def __mark_as_consumed(self) -> None:
        if self.__materialized:
            return

        self.__consuming_state = True
        self.__parent.if_present(_PipelineStage.__mark_as_consumed)


class _SequentialStream(Stream[T], _PipelineStage):  # pylint: disable=too-many-public-methods

    """
    A sequential implementation of Stream
    """

    def __init__(self, iterable: Iterable[T], parent=None, **kwargs) -> None:
        super().__init__(parent, **kwargs)
        self.__iterable = iterable

    @classmethod
    def of(cls, *args) -> Stream[T]:
        if len(args) == 1 and isinstance(args[0], Iterable):
            args = args[0]
        return cls(args)

    @classmethod
    def generate(cls, supplier: Callable[[], T]) -> Stream[T]:
        return cls.of(cls.__generate(require_not_none(supplier)))

    def filter(self, predicate: Callable[[T], bool]) -> Stream[T]:
        return self.__class__(filter(require_not_none(predicate), self.__iterable), self)

    def map(self, mapper: Callable[[T], V]) -> Stream[V]:
        return self.__class__(map(require_not_none(mapper), self.__iterable), self)

    def flat_map(self, mapper: Callable[[T], Iterable[V]]) -> Stream[V]:
        return self.__class__(self.__flat_map(require_not_none(mapper), self.__iterable), self)

    def distinct(self, comparator: Callable[[T], K] = identity) -> Stream[T]:
        return self.__class__(self.__distinct(require_not_none(comparator), self.__iterable), self)

    def sorted(self, comparator: Callable[[T], K] = identity, reverse: bool = False) -> Stream[T]:
        return self.__class__(self.__lazy_sorted(require_not_none(comparator), reverse, self.__iterable), self)

    def reversed(self) -> Stream[T]:
        return self.__class__(self.__lazy_reversed(self.__iterable), self)

    def peek(self, consumer: Callable[[T], None]) -> Stream[T]:
        return self.__class__(self.__peek(require_not_none(consumer), self.__iterable), self)

    def enumerate(self) -> Stream[Tuple[int, T]]:
        return self.__class__(enumerate(self.__iterable), self)

    def zip(self, other: Stream[V]) -> Stream[Tuple[T, V]]:
        return self.__class__(itertools.zip_longest(self, require_not_none(other)))

    def limit(self, max_size: int) -> Stream[T]:
        return self.__class__(self.__limit(max_size, self.__iterable), self)

    def skip(self, n: int) -> Stream[T]:
        return self.__class__(self.__skip(n, self.__iterable), self)

    def take_while(self, predicate: Callable[[T], bool]) -> Stream[T]:
        return self.__class__(itertools.takewhile(require_not_none(predicate), self.__iterable), self)

    def drop_while(self, predicate: Callable[[T], bool]) -> Stream[T]:
        return self.__class__(itertools.dropwhile(require_not_none(predicate), self.__iterable), self)

    def for_each(self, consumer: Callable[[T], None]) -> None:
        self.__for_each(require_not_none(consumer), self)

    def union(self, other: Stream[V]) -> Stream[Union[T, V]]:
        return self.__class__(itertools.chain(self, require_not_none(other)))

    def transform(self, transform: Callable[[Stream[T]], Stream[V]]) -> Stream[V]:
        return require_not_none(transform)(self)

    def materialize(self) -> Stream[T]:
        return self.__class__(self.to_list(), materialized=True)

    def collect(self, collector: Callable[[Iterator[T]], V]) -> V:
        return require_not_none(collector)(iter(self))

    def iterator(self) -> Iterator[T]:
        return self.collect(identity)

    def to_list(self: Stream[T]) -> List[T]:
        return self.collect(list)

    def to_set(self: Stream[T]) -> Set[T]:
        return self.collect(set)

    def to_dict(self: Stream[Tuple[K, V]]) -> Dict[K, V]:
        return self.collect(dict)  # noqa

    def reduce(self, accumulator: Callable[[T, T], T], initial: T = _not_defined) -> Union[T, Optional[T]]:
        return self.__reduce(require_not_none(accumulator), initial, self)

    def min(self, comparator: Callable[[T], V] = identity) -> Optional[T]:
        return self.__minmax(min, require_not_none(comparator), self)

    def max(self, comparator: Callable[[T], V] = identity) -> Optional[T]:
        return self.__minmax(max, require_not_none(comparator), self)

    def count(self) -> int:
        return len(self.to_list())

    def any_match(self, predicate: Callable[[T], bool] = bool) -> bool:
        return any(self.map(require_not_none(predicate)))

    def all_match(self, predicate: Callable[[T], bool] = bool) -> bool:
        return all(self.map(require_not_none(predicate)))

    def none_match(self, predicate: Callable[[T], bool] = bool) -> bool:
        require_not_none(predicate)
        return self.all_match(lambda item: not predicate(item))

    def find_first(self) -> Optional[T]:
        return self.__find_first(self)

    def key_by(self: Stream[T], mapper: Callable[[T], K]) -> Stream[Tuple[K, T]]:
        require_not_none(mapper)
        return self.map(lambda x: (mapper(x), x))

    def keys(self: Stream[Tuple[K, V]]) -> Stream[K]:
        return self.map(operator.itemgetter(0))

    def values(self: Stream[Tuple[K, V]]) -> Stream[V]:
        return self.map(operator.itemgetter(1))

    def map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], T]) -> Stream[Tuple[K, T]]:
        require_not_none(mapper)
        return self.map(lambda kv: (kv[0], mapper(kv[1])))

    def flat_map_values(self: Stream[Tuple[K, V]], mapper: Callable[[V], Iterable[T]]) -> Stream[Tuple[K, T]]:
        require_not_none(mapper)
        return self.flat_map(lambda kv: ((kv[0], x) for x in mapper(kv[1])))

    def group_by(
            self: Stream[T], classifier: Callable[[T], K], downstream: Callable[[T], V] = identity
    ) -> Stream[Tuple[K, Iterable[V]]]:
        return self \
            .key_by(require_not_none(classifier)) \
            .group_by_key(require_not_none(downstream))

    def group_by_key(self, downstream: Callable[[V], T] = identity) -> Stream[Tuple[K, Iterable[T]]]:
        return self \
            .__group_by_key(require_not_none(downstream)) \
            .map_values(list)

    def reduce_by_key(self, accumulator: Callable[[T, V], T], initial: T = _not_defined) -> Stream[Tuple[K, T]]:
        return self.__reduce_by_key(require_not_none(accumulator), initial)

    def joining(self: Stream[T], delimiter: str = '', prefix: str = '', suffix: str = '') -> str:
        return ''.join((
            require_not_none(prefix), require_not_none(delimiter).join(self.map(str)), require_not_none(suffix)
        ))

    def __iter__(self):
        with self._disposable_consume():
            return iter(self.__iterable)

    @staticmethod
    def __generate(supplier: Callable[[], T]):
        while True:
            yield supplier()

    @staticmethod
    def __flat_map(mapper: Callable[[T], Iterable[V]], iterable: Iterable[T]):
        for item in iterable:
            yield from mapper(item)

    @staticmethod
    def __distinct(comparator: Callable[[T], V], iterable: Iterable[T]):
        unique_keys = set()
        for item in iterable:
            item_key = comparator(item)
            if item_key not in unique_keys:
                unique_keys.add(item_key)
                yield item

    @staticmethod
    def __lazy_sorted(comparator: Callable[[T], K], reverse: bool, iterable: Iterable[T]):
        yield from sorted(iterable, key=comparator, reverse=reverse)

    @staticmethod
    def __lazy_reversed(iterable: Iterable[T]):
        if not isinstance(iterable, Reversible):
            iterable = list(iterable)
        yield from reversed(iterable)

    @staticmethod
    def __peek(consumer: Callable[[T], None], iterable: Iterable[T]):
        for item in iterable:
            consumer(item)
            yield item

    @staticmethod
    def __limit(max_size: int, iterable: Iterable[T]):
        try:
            yield from iterable[:max_size] if max_size > 0 else []
        except TypeError:
            for index, item in enumerate(iterable):
                if index >= max_size - 1:
                    yield item
                    break
                yield item

    @staticmethod
    def __skip(n: int, iterable: Iterable[T]):
        try:
            yield from iterable[(n if n >= 0 else 0):]
        except TypeError:
            iterator = iter(iterable)
            for index, item in enumerate(iterator):
                if index >= n:
                    yield item
                    break

            yield from iterator

    @staticmethod
    def __for_each(consumer: Callable[[T], None], iterable: Iterable[T]):
        for item in iterable:
            consumer(item)

    @staticmethod
    def __reduce(accumulator: Callable[[T, T], T], initial: T, iterable: Iterable[T]):
        reduce = functools.partial(functools.reduce, accumulator, iterable)
        if initial != _not_defined:
            return reduce(initial)
        try:
            return Optional.of_nullable(reduce())
        except TypeError:
            return Optional.empty()

    @staticmethod
    def __minmax(func, comparator: Callable[[T], V], iterable: Iterable[T]):
        try:
            return Optional.of_nullable(func(iterable, key=comparator))
        except ValueError:
            return Optional.empty()

    @staticmethod
    def __find_first(iterable: Iterable[T]):
        try:
            return Optional.of_nullable(next(iter(iterable)))
        except StopIteration:
            return Optional.empty()

    def __group_by_key(self, downstream: Callable[[V], T]):
        def func(stream: Stream[Tuple[K, V]]):
            for key, values in itertools.groupby(iter(stream), operator.itemgetter(0)):
                yield key, (downstream(value) for _, value in values)

        return self \
            .sorted(operator.itemgetter(0)) \
            .transform(lambda stream: self.__class__(func(stream)))

    def __reduce_by_key(self, accumulator: Callable[[T, V], T], initial: T):
        def func(iterable: Iterable[V]):
            return functools.reduce(accumulator, iterable, *args)

        args = (initial,) if initial != _not_defined else ()
        return self \
            .__group_by_key(identity) \
            .map_values(func)
